Latte, frontend

Students, Srodowisko
====================
```
$ rustc --version
```
Lokalnie pracuje z najnowsza wersja (1.31.1). Zalecana jest aktualizacja
kompilatora (nie trwa to dlugo), poniewaz moj kod miejscami korzysta
z niedawnych zmian w kompilatorze Rusta.

Instalacja Rusta (na wszelki wypadek):
```
$ curl https://sh.rustup.rs -sSf | sh
```
Aktualizacja Rusta:
```
$ rustup update
```
Zbudowanie projektu:
```
$ make
```
`latc` jest skrotem do `latc_llvm --make-executable`.

Uruchamialem u siebie lokalnie testy oficjalne i te dodatkowe od studentow -
wszystko dziala tak, jak powinno.

Podjete decyzje
===============

(Odnosnie rozszerzen, nie wszystko co jest napisane w readme,
jest zaimplementowane w backendzie.)

- zmienilem skladnie dla indeksowania tablicy: `arr.[idx]`
- nie wspieram rzutowania
- `for(int x : arr) {...}` jest rownoznaczny:
```
int i = 0;
while (i < arr.length) {
  // zmienna lokalna jedyna w swoim zakresie widocznosci,
  // i w zaleznosci od typu - operujemy na kopii lub referencji
  int x = arr.[i];
  {...}
}
```
- dopuszczam martwy kod (np. `if (true)` czy `while (false)`)
- optymalizacja: nie generuje kodu dla martwej galezi if-a ani ciala while'a,
  jesli warunek petli jest falszywy, ani kodu po `while (true)` (obliczam
  wyrazenia stale, ktore nie zawieraja zmiennych),
- optymalizacja: nie generuje bloku dla galezi else, jesli nie istnieje ona
  w kodzie
- brak sztucznych ograniczen przy wyrazeniach - np. mozna odwolac sie do pola
  obiektu, gdy obiekt jest wynikiem wyrazenia, a nie tylko zmienna, podobnie
  przy tablicach
- programista odpowiada za weryfikacje, czy referencja do obiektu lub tablicy
  nie jest nullem, wpp. zachowanie jest niezdefiniowane (prawdopodobnie bedzie
  segfault),
- string jest typem referencyjnym, ale nigdy nie jest nullem (domyslnie jest
  napisem pustym),
- poprawnym jest:
```
void foo() {}
void bar() {return foo();}
```
- wszelkie symbole (funkcje, zmienne, klasy) wspoldziela przestrzenie nazw,
  tzn. nie mozna miec klasy i globalnej funkcji o tej samej nazwie ani
  pola w klasie i metody o tej samej nazwie,
- w przypadku dlugiego literalu liczbowego, parser moze sie scrashowac,
- w metodach, nie ma self, this ani tym podobnych (TODO (ext) rozwazyc zmiane),
- dzielenie przez zero w wyrazeniach stalych jest wykrywane w czasie
  parsowania (mozna dostac syntax error i obok dzielenie przez 0),
- wystepuja niejawne konwersje: podklasy do nadklasy, oraz nulla do klasy
  lub tablicy,
- optymalizacja: inkrementacja i dekrementacja (operatory ++ i --)
  np. `a.[4]++` tylko raz obliczy adres elementu `a.[4]`,
- tablice moga byc wielowymiarowe:
```
int[][] v = new int[][42];
// typeof(v[0]) == int[]
// v[0] == null // domyslna wartosc
```
- generowany kod jest w postaci SSA: wszystkie zmienne lokalne
  sa w rejestrach, a load i store uzywane sa wylacznie do danych na stercie,
- optymalizacja: funkcje phi w bloku po ifie emituje tylko dla tych zmiennych
  ktore maja rozne wartosci (stala lub rejestr) w zaleznosci od bloku
  poprzednika; w przypadku while'a emituje funkcje phi dla wszystkich
  zmiennych lokalnych (chce uniknac (1) dodatkowej globalnej analizy,
  jakie zmienne wystepuja, bo to czasochlonne dla programisty,
  i (2) przechodzenie przez cialo bloku dwukrotnie, bo gdy takie bloki
  zagniezdzimy to mamy algorytm wykladniczy),
- optymalizacja: jesli da sie tego uniknac, nie generuje kodu dla ! (negacji
  logicznej), tzn. w przypadku, gdy wynik decyduje gdzie skoczyc, a nie jest
  zapisywany na zmienna,
- w kodzie LLVM-a tworze nowe bloki dla syntaktycznych blokow w kodzie Latte
  (uwaga: petle i ify maja u mnie blok w AST, a nie instrukcje - nawet jesli
  w tekscie programu nie ma znakow {}), stad w grafie przeplywu sterowania
  moze wystepowac w wygenerowanym kodzie dluga sciezka bez rozgalezien,


Drobne uwagi
============

- generator parserow lalrpop, z ktorego korzystam, nie wspiera komentarzy,
  wiec recznie je usuwam przed przekazaniem kodu do parsera (testowalem,
  ale zawsze moglem cos przeoczyc),
- staram sie wypisac tyle bledow na raz ile sie da,
- 1 pkt za SSA to zdecydowanie za malo; llvm duzo wymaga od IR-u, przez co
  zaimplementowanie wszystkich zmiennych lokalnych na funkcjach phi wymagalo
  duzo nowego kodu, aby kompilator llvm-a byl zadowolony


Opis kompilacji runtime'u znajduje sie w `compile-runtime.sh`
Opis kompilacji reszty znajduje sie w `src/main.rs`
