Latte, frontend

Students, Srodowisko
====================

  $ rustc --version

Lokalnie pracuje z najnowsza wersja (1.31.0), na studentsie mam 1.29.2
(zainstalowana przed oddaniem instanta) i kod rowniez sie tam kompiluje.

Instalacja Rusta (na wszelki wypadek)::

  $ curl https://sh.rustup.rs -sSf | sh

Aktualizacja Rusta::

  $ rustup update

Zbudowanie projektu::

  $ make

`latc` jest skrotem do `latc_llvm --make-executable`.


Podjete decyzje
===============

- zmienilem skladnie dla indeksowania tablicy: arr.[idx]
- nie wspieram rzutowania
- for(int x : arr) {...} jest rownoznaczny::

    int i = 0;
    while (i < arr.length) {
      int x = arr.[i]; // jedyna w swoim zakresie widocznosci,
                      // w zaleznosci od typu -
                      // operujemy na kopii lub referencji
      {...}
    }

- dopuszczam martwy kod (np. if true czy while false)
- brak sztucznych ograniczen przy wyrazeniach - np. mozna odwolac sie do pola
  obiektu, gdy obiekt jest wynikiem wyrazenia, a nie tylko zmienna, podobnie
  przy tablicach
- programista odpowiada za weryfikacje, czy referencja do obiektu lub tablicy
  nie jest nullem, wpp. zachowanie jest niezdefiniowane (prawdopodobnie bedzie
  segfault),
- string jest typem referencyjnym, ale nigdy nie jest nullem (domyslnie jest
  napisem pustym),
- poprawnym jest:
  void foo() {}
  void bar() {return foo();}
- wszelkie symbole (funkcje, zmienne, klasy) wspoldziela przestrzenie nazw,
  tzn. nie mozna miec klasy i globalnej funkcji o tej samej nazwie ani
  pola w klasie i metody o tej samej nazwie,
- w przypadku dlugiego literalu liczbowego, parser moze sie scrashowac,
- w metodach, nie ma self, this ani tym podobnych,
- dzielenie przez zero w wyrazeniach stalych jest wykrywane w czasie
  parsowania (mozna dostac syntax error i obok dzielenie przez 0),
- wystepuja niejawne konwersje: podklasy do nadklasy, oraz nulla do klasy
  lub tablicy,
- inkrementacja i dekrementacja (operatory ++ i --) sa zoptymalizowane -
  np. a[4]++ tylko raz obliczy adres elementu a[4],
- tablice moga byc wielowymiarowe::

    int[][] v = new int[][42];
    // typeof(v[0]) == int[]
    // v[0] == null // domyslna wartosc

- generowany kod jest w postaci SSA: wszystkie zmienne lokalne
  sa w rejestrach, a load i store uzywane sa wylacznie do danych na stercie
- optymalizacja: funkcja phi jest uzywana wylacznie do zmiennych, ktorych
  wartosc ulegla zmianie w trakcie rozgalezienia w grafie przeplywu sterowania


Drobne uwagi
============

- cargo run buduje projekt, jesli nie jest zbudowany lub sie zmieni,
  a za zmiane uwaza sie rowniez zmiane plikow lokalnych, wiec warto
  trzymac pliki .lat poza katalogiem projektu (albo uruchamiac binarke
  bezposrednio - jest gdzies w katalogu target/).
- generator parserow lalrpop, z ktorego korzystam, nie wspiera komentarzy,
  wiec recznie je usuwam przed przekazaniem kodu do parsera (testowalem,
  ale zawsze moglem cos przeoczyc),
- staram sie wypisac tyle bledow na raz ile sie da,
- uruchamialem testy przykladowe i studentow - wszystko dziala jak powinno


Opis kompilacji runtime'u znajduje sie w `compile-runtime.sh`
Opis kompilacji reszty znajduje sie w `src/main.rs`
